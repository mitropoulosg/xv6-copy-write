Ονοματεπώνυμο: Μητρόπουλος Γιώργος
ΑΜ: 1115202000128


Βήμα 1 – Εκτυπώστε τον πίνακα σελίδων:

defs.h:
Προσθήκη ορισμού της void vmprint(pagetable_t pagetable) και κλήση της στo exec.c στην συνάρτηση exec.

vm.c:
Η συνάρτηση βρίσκεται προς το τέλος του αρχείου vm.c όπου καλει την αναδρομικη συναρτηση print_pagetable(pagetable_t pagetable, int level) η οποία εκτυπώνει αναδρομικά τον πίνακα σελίδων. 

Το level δείχνει το επίπεδο στο οποίο βρίσκομαστε με 0 το ανώτατο, 1 το αμέσως κατώτερο κι 2 το κατώτερο. Η χρήση του level είναι για την εκτύπωση του σωστού αριθμού από ' ..' strings ,pte και pa. 

Η επανάληψη γίνεται για i απο 0 μέχρι 511(2^9) όπως δείχνει και ο πίνακας σελίδων στην εκφώνηση. 
 
Για καθε level εκτυπώνεται το pte και η φυσική διεύθυνση (pa) μέσω της συνάρτησης PTE2PA().,οταν δε υπαρχει κατι αλλο 
να εκτυπωθει το level αυξανεται και καλειται ξανα η συναρτηση αναδρομικα.


Βήμα 2 - Απομακρυνση εκχωρησης μνημης απο την sbrk()

Τροποποίηση της συνάρτησης  sys_sbrk(void) στο sysproc.c. Συγκεκριμένα, η μεταβλητή addr παίρνει το μέγεθος της διεργασίας ( size του myproc()). Αν το n είναι θετικό, τότε προστίθεται στο myproc()->sz.(myproc()->size+n) Αν είναι αρνητικό, καλείται η growproc(n) για να μειώσει τη μνήμη κατά n.


Βήμα 3 – lazy allocation:

Γίνεται include των αρχείων spinlock.h και proc.h λόγω σφάλματος “incomplete type proc” στο vm.c. 
Τροποποίηση των uvmunmap() και uvmcopy() έτσι ώστε να μην γίνεται panic. Για να διαχειρίζονται καλύτερα την περίπτωση όπου μερικές σελίδες δεν έχουν αντιστοιχιστεί, γίνεται continue στην επόμενη επανάληψη.

Στο αρχείο trap.c, τροποποίηση της void usertrap(void). Ειδικότερα, αν έγινε σφάλμα σελίδας (αν η r_scause() έχει τιμή 13 ή 15), καλείται μια νεα συναρτηση η lazyalloc(struct proc * p, r_stval()). αν επιστρεψε <=0 η συναρτηση αυτη, τερματιζεται η διαδικασια

lazyalloc:
ελέγχει αν έχουμε μη έγκυρη σελίδα κάτω από τη στοίβα χρήστη ή αν έχουμε διεύθυνση εικονικής μνήμης υψηλότερη από οποιαδήποτε ανατεθείσα μέσω της sbrk() , αν ισχυει κατι απο τα 2 επιστρεφει 0.

Στην συνεχεια καλειται η kalloc κι αν αποτύχει επιστρεφει 0. 
Ειδάλλως, ακολουθείται ο κώδικας uvmalloc() στο vm.c, συγκεκριμένα, αντιγράφεται κι τροποποιείται το εξής τμήμα:
memset(mem, 0, PGSIZE);
if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
	kfree(mem);
	uvmdealloc(pagetable, a, oldsz);
	return 0;
}


Για την περίπτωση όπου μία διεργασία περνάει μία έγκυρη διεύθυνση από την sbrk() σε μία κλήση συστήματος όπως η read() ή write(), αλλά η μνήμη για τη διεύθυνση αυτή δεν έχει ακόμη ανατεθεί γίνεται τροποποίηση walkaddr() που καλούν οι copyin(), copyout() (read, write) (βρίσκονται στο αρχείο vm.c). 

Στη walkaddr():
if(pte == 0)
  goto lazy;

  if((*pte & PTE_V) == 0)
  goto lazy;

  if((*pte & PTE_U) == 0)
  goto lazy;

  οπου στο lazy: καλειται παλι η lazyallocation 


Συνολικά, τροποποιήθηκαν τα εξής αρχεία: defs.h, exec.c, sysproc.c, trap.c, vm.c.
Καλώντας make grade, εκτυπώνεται score 100/100:
